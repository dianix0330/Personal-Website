The challenging part of building custom calendar component is to implement  locking the race condition problems. 

To handle race conditions in a calendar component on the frontend side, I used single source of data, I mean calendar component didn’t store any data related to appointment in multiple places, such as the local state or separate database. Instead, all changes and all appointments were stored this database, and it could be synchronized across all the clients. By doing this, I effectively and handled race conditions. And then I locked certain appointments by mutex locks, you know mutex lock is a way of ensuring that only one operation is performed at a time, which can help to prevent race conditions from occurin’] And to update the calendar status quickly on the frontend side, we used WebSocket.

**When handling race conditions in a calendar component on the frontend side, it is important to use a single source of truth. This means that the calendar component should not store data in multiple places, such as the local state or a separate database. Instead, all changes should be made through this single source of truth, which can be synchronized across all clients. This will help to ensure that all clients have the same version of the calendar component and will prevent race conditions from occurring.**

**Additionally, certain actions can be protected by mutex locks. A mutex lock is a way of ensuring that only one operation is performed at a time, which can help to prevent race conditions from occurring. For example, if two users are attempting to edit the same calendar entry at the same time, a mutex lock can ensure that only one user is able to edit the entry at a time.**

**Finally, it is important to have tests in place to detect any race conditions that may occur. These tests should be run regularly to ensure that any changes to the calendar component do not cause any race conditions. In addition, any changes to the code should be thoroughly tested to ensure that no race conditions occur.**

**The best solution for handling race conditions in a calendar component is to use a single source of truth and mutex locks. This will ensure that all clients have the same version of the calendar component at any given time, and any actions can be protected by mutex locks to ensure that only one operation is performed at a time.**


In my last company, I worked as a senior frontend engineer responsible for developing and maintaining hitask. It is a kind of task management system which is designed to help people and development teams to manage their projects more effciently. In this project, my main responsibility was to develop front-end pages like task management dashboard and calendar board using React, Bootstrap, GraphQL and Typescript. I was also responsible for optimizing the performance of the app and troubleshotting the issue that arose.  
My another responsibility was to provide technical support and guidance to other team members as well as mentoring and helping them. I also wrote unit tests for my components using Jest and React Testing Library.
And in terms of development work flow, our team followed agile scrum methodology with 2 wks sprints.
And I participated in several scrum ceremonies like grooming, planning, retro and daily standups and discussed the process of tickets, sprints with others.

Well, up to now, I have developed several projects in various companies, and let me tell you about one of them. That project is hitask, a kind of project management system like Jira board. The purpose of this project is to remove the complexity from project management and provides an easier way to clients to manage their products. It is very easy to use. Its dashboard allows you to see all of your tasks and collaboration tools in one window. It is very popular with over 500 000 users and companies. It also provides several reporting tools that let you easily track and measure your work progress. So hitask provides you with many features such as project management, document storage, shared calendar, sharing permissions, time tracking, and so on. In task management, you can add a task and edit a task: name, description, period, reminder, assignment, sharing, client/project, tags. And in scheduling, you can see the process of each task(ticket) in the calendar. Um.. in that project, I was responsible for task and calendar management. This project requires so many reusable UI components and I used Storybooks for this implementation. In that project, I used React, Javascript(Typescript), and GraphQL.

